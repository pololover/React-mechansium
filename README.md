# React-mechansium

React vs ReactDom
----
React는 props, state, context가 바뀔 때 컴포넌트를 재실행시켜주는 것.   
ReactDom은 React에서 재실행시켜준 것을 기반으로 이전 snapshot과 비교해서 변경된 부분이 있으면 그 부분만 실제 DOM에 적용 시켜주는 것.    

자식 컴포넌트에서 prop이 변하지 않아도 부모의 state가 변한다면 자식들도 따라서 재실행이 된다. 하지만 자식 컴포넌트가 재실행된다고해서 실제 DOM에 영향을 주는 것은 아님.      

React.memo는 컴포넌트의 상태값이 변화하지 않을때 재랜더링하지 않게 해주는 리액트 훅이다. 이를 적용함으로써 부모쪽에서 변화가 되었지만 자식쪽에서 재렌더링이 필요로하지 않는 부분에서는 하지 않게 함으로써 최적화가 가능하다.    
하지만 함수를 props로 전달한다고 했을 때 함수 내부 state의 값이 변하지 않아도 재렌더링 되는 것을 볼 수 있는데 이는 자바스크립트에서 객체(함수), 배열은 reference타입이기 때문이다. 즉 props로 넘겨줄 때 같은 이름의 같은 기능의 함수더라도 다른 값으로 판별이 되기 때문에 이를 같은 이름의 같은 기능이라면 같은 함수로 판별하도록 만들어야 한다.    

useCallback
-----
useCallback 리액트 훅을 사용하면 위와 같은 내용을 해결할 수 있다. useCallback안에는 함수를 정의할 수 있는데 이 함수가 정의된다면 react내부에서 이 함수를 메모리에 넣고 기억하게 된다. 이 의미는 곧 같은이름의 같은 기능이 props로 전달이 되었을 때 기존 메모리에 있는 값과 같다면 같다고 판별하기 때문에 불필요한 렌더링을 하지 않게 된다. useCallback에는 useEffect와 같이 dependencies를 넣을 수 있는데 이는 useCallback내부의 함수에서 사용하는 값이 변화할 때, 함수를 다시 실행하게 된다. 왜 이게 필요하는지는 자바스크립트 클로저와 관련이 있다.     
클로저는 자바스크립트의 함수가 선언되었을 때의 렉시컬 환경을 기억하는 개념이다. 즉 usecallback내부의 함수가 선언되었을 때 그 안에서 사용하는 변수는 처음 선언되었을 때의 내용을 기억하는 것이다. 이 상태에서 dependencies를 정의하지 않는다면 함수가 실행되었을 때 인자를 사용할 수 없게 된다. 왜냐하면 dependencies가 변화하지 않는 한 내부의 값은 변하지 않도록 만드는 게 useCallback이기 때문이다. 따라서 이 훅안에서 쓰일 변수들은 dependencies로 정의해줘야 한다.    


React memo와 useCallback의 조합
------
useCallback은 렌더링의 불필요한 렌더링을 줄이기 위해서 React.memo와도 사용이 가능하다.     
예시로 토글을 했을 때 컬러가 변하는 colorChange라는 이벤트 컴포넌트가 있을 때 이 컴포넌트를 사용하는 A,B,C의 state와 클릭에 대한 핸들러가 있다고 가정해보자. 이들은 A를 토글했을 때, B를 토글했을 때, C를 토글했을 때 전부 각각의 state를 변경해주는 함수들이다.       
이 상태에서 colorChange 컴포넌트를 react.memo를 시키면 A를 토글했을 때는 B와 C는 재렌더링이 되지 않는 것을 예상하지만 결과는 그렇지않다. 이는 위의 정의한 것과 같은 이유로 자바스크립트에서 함수는 객체로 정의되고 이는 값이 같아도 메모리 주소가 다르면 다르다고 판별하기 떄문에 일어난다. 따라서 함수핸들러마다 useCallback에 감싸주면 원하지않는 부분은 렌더링이 되지 않는 것을 볼 수 있다.
